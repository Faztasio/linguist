#!/usr/bin/env ruby
# coding: utf-8

CWD = Dir.pwd
Dir.chdir(__dir__)
require "bundler/setup"
require "linguist"
require "optparse"
require "pp"
Manpage = Linguist::Strategy::Manpage
Dir.chdir(CWD)


class ManpageTester
  SKIP_DIRS = /^\.(?:git|svn|hg)$/

  # Various cosmetic formatting junk
  GREY  = "\e[38;5;8m"
  RED   = "\e[31;38;5;196m"
  GREEN = "\e[32;38;5;40m"
  RESET = "\e[0m"
  TICK  = "✓ "
  CROSS = "✘ "

  def initialize
    @failed_only = false
    @recursive   = true
    @failures    = []
    @matches     = []
    @show_errors = false
  end

  attr_accessor :show_all, :recursive, :failures, :matches

  # Public: Scan files for "well-formedness"
  def test(path)
    if File.file?(path)
      test_file(path)
    elsif @recursive && File.directory?(path)
      recurse(path).each { |path| test_file(path) }
    end
  end

  # Public: Display a summary and list files which didn't match
  def show_summary
    total = @failures.count + @matches.count
    if @failures.count > 0
      puts RED + @failures.count.to_s + " out of #{total.to_s} manpages failed to match#{RESET}"
      exit 1
    elsif @matches.count > 0
      puts GREEN + total.to_s + " all matched!" + RESET
    else
      puts GREY + "Found no manpages to check." + RESET
    end
  end

  # Internal: Recursively load all files within a directory
  def recurse(root, depth = 0)
    return if !@recursive && depth > 0
    files = []
    root = root.sub(/[\/\\]\Z/, "")
    Dir.children(root).each do |name|
      absname = root + File::SEPARATOR + name
      if File.directory?(absname) && !SKIP_DIRS.match?(absname)
        files.concat recurse(absname, ++depth)
      elsif File.file?(absname)
        files << absname
      end
    end
    files.sort.uniq
  end

  # Internal: Determine if a manpage is well-formed
  def test_file(path)
    return unless Manpage::MANPAGE_EXTS.match?(path)
    begin
      blob = Linguist::Blob.new(path, File.read(path))
      return if blob.large?
      result = Manpage.call(blob)
      if result.empty?
        @failures << path
        show_fail path
      elsif
        @matches << path
        show_pass path
      end
    rescue StandardError => error
      show_error error, path
    end
  end

  # Internal: Indicate that a file is a well-formed manpage
  def show_pass(path)
    return if @failed_only
    puts GREEN + TICK + path + RESET
  end

  # Internal: Indicate that file isn't a well-formed manpage
  def show_fail(path)
    puts RED + CROSS + path + RESET
  end

  # Internal: Display any exceptions which were raised during execution.
  # They're usually related to the encoding of loaded content, which is
  # annoying, but generally safe to ignore.
  def show_error(error, path = "")
    return unless @show_errors
    path = " #{path}" if path
    puts RED + CROSS + "ERROR:" + path
    puts error.inspect.gsub(/^/, "\t") + RESET
  end
end


tester = ManpageTester.new()

# Handle CLI options
OptionParser.new do |opts|
  opts.banner = "Usage:\n  #{$0} [-a|--all] ...files"
  opts.on("-e", "--show-errors", "Show raised exceptions caught during recursion") do
    tester.show_errors = true
  end
  opts.on("-f", "--failed-only", "Show failed matches only") do
    tester.failed_only = false
  end
end.parse!


ARGV.each {|arg| tester.test(arg)}

tester.show_summary
